"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.popPath = popPath;
exports.resolveNodeNoSideEffects = resolveNodeNoSideEffects;
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _path = require("path");

var _url = require("url");

var _xmlhttprequest = require("xmlhttprequest");

var _error = _interopRequireWildcard(require("./error"));

var _utils = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function pushPath(ctx, filePath, docPath) {
  ctx.pathStack.push({
    path: ctx.path,
    file: ctx.filePath,
    document: ctx.document,
    source: ctx.source
  });
  ctx.path = docPath;
  ctx.filePath = filePath;
}

function popPath(ctx) {
  const topPath = ctx.pathStack.pop();
  ctx.path = topPath.path;
  ctx.filePath = topPath.file;
  ctx.source = topPath.source;
  ctx.document = topPath.document;
}
/**
 *
 * Here we go over each of the steps in the link and try to retreive the value
 * for it. If failed (e.g. because of undefined value) -- return null, to indicate that such
 * reference does not exist.
 *
 * TODO: we might need a feature to support validation of "URL" based definitions in the future, so
 * would be nice to have opportunity to call resolve() with empty ctx.
 *
 * TODO: add per-file/per-url cache
 *
 * @param {string} link A path in the yaml document which is to be resolved
 * @param {*} ctx JSON Object with the document field which represents the YAML structure
 */


function resolve(link, ctx, visited = []) {
  const linkSplitted = link.split('#/');
  if (linkSplitted[0] === '') linkSplitted[0] = ctx.filePath;
  const [filePath, docPath] = linkSplitted;
  const resolvedFilePath = (0, _utils.isFullyQualifiedUrl)(ctx.filePath) || (0, _utils.isFullyQualifiedUrl)(filePath) ? (0, _url.resolve)(ctx.filePath, filePath) : (0, _path.resolve)((0, _path.dirname)(ctx.filePath), filePath);
  let document;
  let source;
  const isCurrentDocument = resolvedFilePath === ctx.filePath;
  pushPath(ctx, resolvedFilePath, []);
  const resolvedLink = `${resolvedFilePath}#/${docPath}`;

  if (!isCurrentDocument) {
    if (ctx.resolveCache[resolvedFilePath]) {
      ({
        source,
        document
      } = ctx.resolveCache[resolvedFilePath]);
    } else if (_fs.default.existsSync(resolvedFilePath)) {
      ctx.fileDependencies.add(resolvedFilePath); // FIXME: if refernced e.g. md file, no need to parse

      source = _fs.default.readFileSync(resolvedFilePath, 'utf-8');

      try {
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        ctx.result.push((0, _error.createYAMLParseError)(e, ctx, resolvedFilePath));
        return {
          node: undefined
        };
      } // FIXME: lost yaml parsing and file read errors here

    } else if ((0, _utils.isFullyQualifiedUrl)(resolvedFilePath)) {
      try {
        const xhr = new _xmlhttprequest.XMLHttpRequest();
        xhr.open('GET', filePath, false);
        xhr.send();

        if (xhr.status !== 200) {
          return {
            node: undefined
          };
        }

        source = xhr.responseText;
        document = _jsYaml.default.safeLoad(source);
      } catch (e) {
        // FIXME: lost yaml parsing errors and network errors here
        return {
          node: undefined
        };
      }
    } else {
      return {
        node: undefined
      };
    }
  } else {
    document = ctx.document;
    source = ctx.source;
  }

  if (source) ctx.resolveCache[resolvedFilePath] = {
    source,
    document
  };
  ctx.source = source;
  ctx.document = document;
  const docPathSteps = docPath ? docPath.split('/').filter(el => el !== '').reverse() : [];
  let target = document;
  let circular;
  let transitiveResolvesOnStack = 0;
  let transitiveError;

  if (visited.indexOf(resolvedLink) > -1) {
    target = undefined;
    circular = true;
  }

  visited.push(resolvedLink);

  while (target !== undefined) {
    if (target && target.$ref) {
      // handle transitive $ref's
      const resolved = resolve(target.$ref, ctx, visited);
      transitiveError = resolved.transitiveError;

      if (resolved.node === undefined && !transitiveError) {
        // We want to show only the error for the first $ref that can't be resolved.
        // So we create it on the current stack and propagate it out as a transitiveError
        popPath(ctx);
        ctx.path.push('$ref');
        const message = resolved.circular ? 'Circular reference.' : 'Reference does not exist.';
        transitiveError = (0, _error.default)(message, target, ctx, {
          fromRule: 'resolve-ref'
        });
        ctx.path.pop();
        target = undefined;
        break;
      }

      target = resolved.node;
      transitiveResolvesOnStack++;
    }

    const step = docPathSteps.pop();
    if (!step) break;
    target = target && target[step] !== undefined ? target[step] : undefined;
    ctx.path.push(step);
  }

  for (let i = 0; i < transitiveResolvesOnStack; ++i) {
    // keep current file context and remove indirection records
    ctx.pathStack.pop();
  }

  if (transitiveError) {
    // recalc referencedFrom after exiting transitive ref stack to show original $ref in the error
    transitiveError.referencedFrom = (0, _error.getReferencedFrom)(ctx);
  }

  return {
    node: target,
    transitiveError,
    circular
  };
}
/*
 * This function is used to resolve $ref fields inside the node. Currently supports links:
 * - inside the file
 * - to the another file in local file system
 * - http(s) links to other files
 *
 * $ref field value must be a valid OpenAPI link
 * (e.g. another/dir/file.yaml#/components/schemas/Example)
 *
 * @param {*} node
 * @param {*} ctx
 */


function resolveNode(node, ctx) {
  if (!node || typeof node !== 'object') return {
    node
  };

  if (node.$ref) {
    const resolved = resolve(node.$ref, ctx);

    if (resolved.node === undefined) {
      // can't resolve
      popPath(ctx);
      ctx.path.push('$ref');
      const error = resolved.transitiveError ? resolved.transitiveError : (0, _error.default)('Reference does not exist.', node, ctx, {
        fromRule: 'resolve-ref'
      });
      ctx.path.pop();
      ctx.result.push(error);
      return {
        node
      };
    }

    return {
      node: resolved.node,
      onStack: true
    };
  }

  return {
    node
  };
} // to be used in mutators


function resolveNodeNoSideEffects(node, ctx) {
  const ctxCopy = { ...ctx,
    pathStack: ctx.pathStack.slice()
  };
  return resolveNode(node, ctxCopy);
}

var _default = resolveNode;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXNvbHZlci5qcyJdLCJuYW1lcyI6WyJwdXNoUGF0aCIsImN0eCIsImZpbGVQYXRoIiwiZG9jUGF0aCIsInBhdGhTdGFjayIsInB1c2giLCJwYXRoIiwiZmlsZSIsImRvY3VtZW50Iiwic291cmNlIiwicG9wUGF0aCIsInRvcFBhdGgiLCJwb3AiLCJyZXNvbHZlIiwibGluayIsInZpc2l0ZWQiLCJsaW5rU3BsaXR0ZWQiLCJzcGxpdCIsInJlc29sdmVkRmlsZVBhdGgiLCJpc0N1cnJlbnREb2N1bWVudCIsInJlc29sdmVkTGluayIsInJlc29sdmVDYWNoZSIsImZzIiwiZXhpc3RzU3luYyIsImZpbGVEZXBlbmRlbmNpZXMiLCJhZGQiLCJyZWFkRmlsZVN5bmMiLCJ5YW1sIiwic2FmZUxvYWQiLCJlIiwicmVzdWx0Iiwibm9kZSIsInVuZGVmaW5lZCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJkb2NQYXRoU3RlcHMiLCJmaWx0ZXIiLCJlbCIsInJldmVyc2UiLCJ0YXJnZXQiLCJjaXJjdWxhciIsInRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2siLCJ0cmFuc2l0aXZlRXJyb3IiLCJpbmRleE9mIiwiJHJlZiIsInJlc29sdmVkIiwibWVzc2FnZSIsImZyb21SdWxlIiwic3RlcCIsImkiLCJyZWZlcmVuY2VkRnJvbSIsInJlc29sdmVOb2RlIiwiZXJyb3IiLCJvblN0YWNrIiwicmVzb2x2ZU5vZGVOb1NpZGVFZmZlY3RzIiwiY3R4Q29weSIsInNsaWNlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7QUFFQSxTQUFTQSxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsUUFBdkIsRUFBaUNDLE9BQWpDLEVBQTBDO0FBQ3hDRixFQUFBQSxHQUFHLENBQUNHLFNBQUosQ0FBY0MsSUFBZCxDQUFtQjtBQUNqQkMsSUFBQUEsSUFBSSxFQUFFTCxHQUFHLENBQUNLLElBRE87QUFDREMsSUFBQUEsSUFBSSxFQUFFTixHQUFHLENBQUNDLFFBRFQ7QUFDbUJNLElBQUFBLFFBQVEsRUFBRVAsR0FBRyxDQUFDTyxRQURqQztBQUMyQ0MsSUFBQUEsTUFBTSxFQUFFUixHQUFHLENBQUNRO0FBRHZELEdBQW5CO0FBSUFSLEVBQUFBLEdBQUcsQ0FBQ0ssSUFBSixHQUFXSCxPQUFYO0FBQ0FGLEVBQUFBLEdBQUcsQ0FBQ0MsUUFBSixHQUFlQSxRQUFmO0FBQ0Q7O0FBRU0sU0FBU1EsT0FBVCxDQUFpQlQsR0FBakIsRUFBc0I7QUFDM0IsUUFBTVUsT0FBTyxHQUFHVixHQUFHLENBQUNHLFNBQUosQ0FBY1EsR0FBZCxFQUFoQjtBQUNBWCxFQUFBQSxHQUFHLENBQUNLLElBQUosR0FBV0ssT0FBTyxDQUFDTCxJQUFuQjtBQUNBTCxFQUFBQSxHQUFHLENBQUNDLFFBQUosR0FBZVMsT0FBTyxDQUFDSixJQUF2QjtBQUNBTixFQUFBQSxHQUFHLENBQUNRLE1BQUosR0FBYUUsT0FBTyxDQUFDRixNQUFyQjtBQUNBUixFQUFBQSxHQUFHLENBQUNPLFFBQUosR0FBZUcsT0FBTyxDQUFDSCxRQUF2QjtBQUNEO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7QUFjQSxTQUFTSyxPQUFULENBQWlCQyxJQUFqQixFQUF1QmIsR0FBdkIsRUFBNEJjLE9BQU8sR0FBRyxFQUF0QyxFQUEwQztBQUN4QyxRQUFNQyxZQUFZLEdBQUdGLElBQUksQ0FBQ0csS0FBTCxDQUFXLElBQVgsQ0FBckI7QUFDQSxNQUFJRCxZQUFZLENBQUMsQ0FBRCxDQUFaLEtBQW9CLEVBQXhCLEVBQTRCQSxZQUFZLENBQUMsQ0FBRCxDQUFaLEdBQWtCZixHQUFHLENBQUNDLFFBQXRCO0FBQzVCLFFBQU0sQ0FBQ0EsUUFBRCxFQUFXQyxPQUFYLElBQXNCYSxZQUE1QjtBQUVBLFFBQU1FLGdCQUFnQixHQUFJLGdDQUFvQmpCLEdBQUcsQ0FBQ0MsUUFBeEIsS0FBcUMsZ0NBQW9CQSxRQUFwQixDQUF0QyxHQUNyQixrQkFBV0QsR0FBRyxDQUFDQyxRQUFmLEVBQXlCQSxRQUF6QixDQURxQixHQUVyQixtQkFBWSxtQkFBUUQsR0FBRyxDQUFDQyxRQUFaLENBQVosRUFBbUNBLFFBQW5DLENBRko7QUFJQSxNQUFJTSxRQUFKO0FBQ0EsTUFBSUMsTUFBSjtBQUVBLFFBQU1VLGlCQUFpQixHQUFHRCxnQkFBZ0IsS0FBS2pCLEdBQUcsQ0FBQ0MsUUFBbkQ7QUFFQUYsRUFBQUEsUUFBUSxDQUFDQyxHQUFELEVBQU1pQixnQkFBTixFQUF3QixFQUF4QixDQUFSO0FBRUEsUUFBTUUsWUFBWSxHQUFJLEdBQUVGLGdCQUFpQixLQUFJZixPQUFRLEVBQXJEOztBQUVBLE1BQUksQ0FBQ2dCLGlCQUFMLEVBQXdCO0FBQ3RCLFFBQUlsQixHQUFHLENBQUNvQixZQUFKLENBQWlCSCxnQkFBakIsQ0FBSixFQUF3QztBQUN0QyxPQUFDO0FBQUVULFFBQUFBLE1BQUY7QUFBVUQsUUFBQUE7QUFBVixVQUF1QlAsR0FBRyxDQUFDb0IsWUFBSixDQUFpQkgsZ0JBQWpCLENBQXhCO0FBQ0QsS0FGRCxNQUVPLElBQUlJLFlBQUdDLFVBQUgsQ0FBY0wsZ0JBQWQsQ0FBSixFQUFxQztBQUMxQ2pCLE1BQUFBLEdBQUcsQ0FBQ3VCLGdCQUFKLENBQXFCQyxHQUFyQixDQUF5QlAsZ0JBQXpCLEVBRDBDLENBRTFDOztBQUNBVCxNQUFBQSxNQUFNLEdBQUdhLFlBQUdJLFlBQUgsQ0FBZ0JSLGdCQUFoQixFQUFrQyxPQUFsQyxDQUFUOztBQUNBLFVBQUk7QUFDRlYsUUFBQUEsUUFBUSxHQUFHbUIsZ0JBQUtDLFFBQUwsQ0FBY25CLE1BQWQsQ0FBWDtBQUNELE9BRkQsQ0FFRSxPQUFPb0IsQ0FBUCxFQUFVO0FBQ1Y1QixRQUFBQSxHQUFHLENBQUM2QixNQUFKLENBQVd6QixJQUFYLENBQWdCLGlDQUFxQndCLENBQXJCLEVBQXdCNUIsR0FBeEIsRUFBNkJpQixnQkFBN0IsQ0FBaEI7QUFDQSxlQUFPO0FBQUVhLFVBQUFBLElBQUksRUFBRUM7QUFBUixTQUFQO0FBQ0QsT0FUeUMsQ0FVMUM7O0FBQ0QsS0FYTSxNQVdBLElBQUksZ0NBQW9CZCxnQkFBcEIsQ0FBSixFQUEyQztBQUNoRCxVQUFJO0FBQ0YsY0FBTWUsR0FBRyxHQUFHLElBQUlDLDhCQUFKLEVBQVo7QUFDQUQsUUFBQUEsR0FBRyxDQUFDRSxJQUFKLENBQVMsS0FBVCxFQUFnQmpDLFFBQWhCLEVBQTBCLEtBQTFCO0FBQ0ErQixRQUFBQSxHQUFHLENBQUNHLElBQUo7O0FBRUEsWUFBSUgsR0FBRyxDQUFDSSxNQUFKLEtBQWUsR0FBbkIsRUFBd0I7QUFDdEIsaUJBQU87QUFBRU4sWUFBQUEsSUFBSSxFQUFFQztBQUFSLFdBQVA7QUFDRDs7QUFFRHZCLFFBQUFBLE1BQU0sR0FBR3dCLEdBQUcsQ0FBQ0ssWUFBYjtBQUNBOUIsUUFBQUEsUUFBUSxHQUFHbUIsZ0JBQUtDLFFBQUwsQ0FBY25CLE1BQWQsQ0FBWDtBQUNELE9BWEQsQ0FXRSxPQUFPb0IsQ0FBUCxFQUFVO0FBQ1Y7QUFDQSxlQUFPO0FBQUVFLFVBQUFBLElBQUksRUFBRUM7QUFBUixTQUFQO0FBQ0Q7QUFDRixLQWhCTSxNQWdCQTtBQUNMLGFBQU87QUFBRUQsUUFBQUEsSUFBSSxFQUFFQztBQUFSLE9BQVA7QUFDRDtBQUNGLEdBakNELE1BaUNPO0FBQ0x4QixJQUFBQSxRQUFRLEdBQUdQLEdBQUcsQ0FBQ08sUUFBZjtBQUNBQyxJQUFBQSxNQUFNLEdBQUdSLEdBQUcsQ0FBQ1EsTUFBYjtBQUNEOztBQUVELE1BQUlBLE1BQUosRUFBWVIsR0FBRyxDQUFDb0IsWUFBSixDQUFpQkgsZ0JBQWpCLElBQXFDO0FBQUVULElBQUFBLE1BQUY7QUFBVUQsSUFBQUE7QUFBVixHQUFyQztBQUVaUCxFQUFBQSxHQUFHLENBQUNRLE1BQUosR0FBYUEsTUFBYjtBQUNBUixFQUFBQSxHQUFHLENBQUNPLFFBQUosR0FBZUEsUUFBZjtBQUVBLFFBQU0rQixZQUFZLEdBQUdwQyxPQUFPLEdBQUdBLE9BQU8sQ0FBQ2MsS0FBUixDQUFjLEdBQWQsRUFBbUJ1QixNQUFuQixDQUEyQkMsRUFBRCxJQUFRQSxFQUFFLEtBQUssRUFBekMsRUFBNkNDLE9BQTdDLEVBQUgsR0FBNEQsRUFBeEY7QUFFQSxNQUFJQyxNQUFNLEdBQUduQyxRQUFiO0FBQ0EsTUFBSW9DLFFBQUo7QUFDQSxNQUFJQyx5QkFBeUIsR0FBRyxDQUFoQztBQUNBLE1BQUlDLGVBQUo7O0FBRUEsTUFBSS9CLE9BQU8sQ0FBQ2dDLE9BQVIsQ0FBZ0IzQixZQUFoQixJQUFnQyxDQUFDLENBQXJDLEVBQXdDO0FBQ3RDdUIsSUFBQUEsTUFBTSxHQUFHWCxTQUFUO0FBQ0FZLElBQUFBLFFBQVEsR0FBRyxJQUFYO0FBQ0Q7O0FBRUQ3QixFQUFBQSxPQUFPLENBQUNWLElBQVIsQ0FBYWUsWUFBYjs7QUFFQSxTQUFPdUIsTUFBTSxLQUFLWCxTQUFsQixFQUE2QjtBQUMzQixRQUFJVyxNQUFNLElBQUlBLE1BQU0sQ0FBQ0ssSUFBckIsRUFBMkI7QUFDekI7QUFDQSxZQUFNQyxRQUFRLEdBQUdwQyxPQUFPLENBQUM4QixNQUFNLENBQUNLLElBQVIsRUFBYy9DLEdBQWQsRUFBbUJjLE9BQW5CLENBQXhCO0FBQ0ErQixNQUFBQSxlQUFlLEdBQUdHLFFBQVEsQ0FBQ0gsZUFBM0I7O0FBQ0EsVUFBSUcsUUFBUSxDQUFDbEIsSUFBVCxLQUFrQkMsU0FBbEIsSUFBK0IsQ0FBQ2MsZUFBcEMsRUFBcUQ7QUFDbkQ7QUFDQTtBQUNBcEMsUUFBQUEsT0FBTyxDQUFDVCxHQUFELENBQVA7QUFDQUEsUUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNELElBQVQsQ0FBYyxNQUFkO0FBQ0EsY0FBTTZDLE9BQU8sR0FBR0QsUUFBUSxDQUFDTCxRQUFULEdBQW9CLHFCQUFwQixHQUE0QywyQkFBNUQ7QUFDQUUsUUFBQUEsZUFBZSxHQUFHLG9CQUFZSSxPQUFaLEVBQXFCUCxNQUFyQixFQUE2QjFDLEdBQTdCLEVBQWtDO0FBQUVrRCxVQUFBQSxRQUFRLEVBQUU7QUFBWixTQUFsQyxDQUFsQjtBQUNBbEQsUUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNNLEdBQVQ7QUFDQStCLFFBQUFBLE1BQU0sR0FBR1gsU0FBVDtBQUNBO0FBQ0Q7O0FBQ0RXLE1BQUFBLE1BQU0sR0FBR00sUUFBUSxDQUFDbEIsSUFBbEI7QUFDQWMsTUFBQUEseUJBQXlCO0FBQzFCOztBQUVELFVBQU1PLElBQUksR0FBR2IsWUFBWSxDQUFDM0IsR0FBYixFQUFiO0FBQ0EsUUFBSSxDQUFDd0MsSUFBTCxFQUFXO0FBRVhULElBQUFBLE1BQU0sR0FBR0EsTUFBTSxJQUFJQSxNQUFNLENBQUNTLElBQUQsQ0FBTixLQUFpQnBCLFNBQTNCLEdBQXVDVyxNQUFNLENBQUNTLElBQUQsQ0FBN0MsR0FBc0RwQixTQUEvRDtBQUNBL0IsSUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNELElBQVQsQ0FBYytDLElBQWQ7QUFDRDs7QUFFRCxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdSLHlCQUFwQixFQUErQyxFQUFFUSxDQUFqRCxFQUFvRDtBQUNsRDtBQUNBcEQsSUFBQUEsR0FBRyxDQUFDRyxTQUFKLENBQWNRLEdBQWQ7QUFDRDs7QUFFRCxNQUFJa0MsZUFBSixFQUFxQjtBQUNuQjtBQUNBQSxJQUFBQSxlQUFlLENBQUNRLGNBQWhCLEdBQWlDLDhCQUFrQnJELEdBQWxCLENBQWpDO0FBQ0Q7O0FBRUQsU0FBTztBQUNMOEIsSUFBQUEsSUFBSSxFQUFFWSxNQUREO0FBRUxHLElBQUFBLGVBRks7QUFHTEYsSUFBQUE7QUFISyxHQUFQO0FBS0Q7QUFHRDs7Ozs7Ozs7Ozs7Ozs7QUFZQSxTQUFTVyxXQUFULENBQXFCeEIsSUFBckIsRUFBMkI5QixHQUEzQixFQUFnQztBQUM5QixNQUFJLENBQUM4QixJQUFELElBQVMsT0FBT0EsSUFBUCxLQUFnQixRQUE3QixFQUF1QyxPQUFPO0FBQUVBLElBQUFBO0FBQUYsR0FBUDs7QUFFdkMsTUFBSUEsSUFBSSxDQUFDaUIsSUFBVCxFQUFlO0FBQ2IsVUFBTUMsUUFBUSxHQUFHcEMsT0FBTyxDQUFDa0IsSUFBSSxDQUFDaUIsSUFBTixFQUFZL0MsR0FBWixDQUF4Qjs7QUFDQSxRQUFJZ0QsUUFBUSxDQUFDbEIsSUFBVCxLQUFrQkMsU0FBdEIsRUFBaUM7QUFBRTtBQUNqQ3RCLE1BQUFBLE9BQU8sQ0FBQ1QsR0FBRCxDQUFQO0FBRUFBLE1BQUFBLEdBQUcsQ0FBQ0ssSUFBSixDQUFTRCxJQUFULENBQWMsTUFBZDtBQUNBLFlBQU1tRCxLQUFLLEdBQUdQLFFBQVEsQ0FBQ0gsZUFBVCxHQUNWRyxRQUFRLENBQUNILGVBREMsR0FFVixvQkFBWSwyQkFBWixFQUF5Q2YsSUFBekMsRUFBK0M5QixHQUEvQyxFQUFvRDtBQUFFa0QsUUFBQUEsUUFBUSxFQUFFO0FBQVosT0FBcEQsQ0FGSjtBQUdBbEQsTUFBQUEsR0FBRyxDQUFDSyxJQUFKLENBQVNNLEdBQVQ7QUFFQVgsTUFBQUEsR0FBRyxDQUFDNkIsTUFBSixDQUFXekIsSUFBWCxDQUFnQm1ELEtBQWhCO0FBRUEsYUFBTztBQUFFekIsUUFBQUE7QUFBRixPQUFQO0FBQ0Q7O0FBRUQsV0FBTztBQUFFQSxNQUFBQSxJQUFJLEVBQUVrQixRQUFRLENBQUNsQixJQUFqQjtBQUF1QjBCLE1BQUFBLE9BQU8sRUFBRTtBQUFoQyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTztBQUFFMUIsSUFBQUE7QUFBRixHQUFQO0FBQ0QsQyxDQUVEOzs7QUFDTyxTQUFTMkIsd0JBQVQsQ0FBa0MzQixJQUFsQyxFQUF3QzlCLEdBQXhDLEVBQTZDO0FBQ2xELFFBQU0wRCxPQUFPLEdBQUcsRUFBRSxHQUFHMUQsR0FBTDtBQUFVRyxJQUFBQSxTQUFTLEVBQUVILEdBQUcsQ0FBQ0csU0FBSixDQUFjd0QsS0FBZDtBQUFyQixHQUFoQjtBQUNBLFNBQU9MLFdBQVcsQ0FBQ3hCLElBQUQsRUFBTzRCLE9BQVAsQ0FBbEI7QUFDRDs7ZUFFY0osVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcyc7XG5cbmltcG9ydCB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlRmlsZSwgZGlybmFtZSB9IGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgcmVzb2x2ZSBhcyByZXNvbHZlVXJsIH0gZnJvbSAndXJsJztcbmltcG9ydCB7IFhNTEh0dHBSZXF1ZXN0IH0gZnJvbSAneG1saHR0cHJlcXVlc3QnO1xuXG5pbXBvcnQgY3JlYXRlRXJyb3IsIHsgZ2V0UmVmZXJlbmNlZEZyb20sIGNyZWF0ZVlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyBpc0Z1bGx5UXVhbGlmaWVkVXJsIH0gZnJvbSAnLi91dGlscyc7XG5cbmZ1bmN0aW9uIHB1c2hQYXRoKGN0eCwgZmlsZVBhdGgsIGRvY1BhdGgpIHtcbiAgY3R4LnBhdGhTdGFjay5wdXNoKHtcbiAgICBwYXRoOiBjdHgucGF0aCwgZmlsZTogY3R4LmZpbGVQYXRoLCBkb2N1bWVudDogY3R4LmRvY3VtZW50LCBzb3VyY2U6IGN0eC5zb3VyY2UsXG4gIH0pO1xuXG4gIGN0eC5wYXRoID0gZG9jUGF0aDtcbiAgY3R4LmZpbGVQYXRoID0gZmlsZVBhdGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3BQYXRoKGN0eCkge1xuICBjb25zdCB0b3BQYXRoID0gY3R4LnBhdGhTdGFjay5wb3AoKTtcbiAgY3R4LnBhdGggPSB0b3BQYXRoLnBhdGg7XG4gIGN0eC5maWxlUGF0aCA9IHRvcFBhdGguZmlsZTtcbiAgY3R4LnNvdXJjZSA9IHRvcFBhdGguc291cmNlO1xuICBjdHguZG9jdW1lbnQgPSB0b3BQYXRoLmRvY3VtZW50O1xufVxuXG4vKipcbiAqXG4gKiBIZXJlIHdlIGdvIG92ZXIgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhlIGxpbmsgYW5kIHRyeSB0byByZXRyZWl2ZSB0aGUgdmFsdWVcbiAqIGZvciBpdC4gSWYgZmFpbGVkIChlLmcuIGJlY2F1c2Ugb2YgdW5kZWZpbmVkIHZhbHVlKSAtLSByZXR1cm4gbnVsbCwgdG8gaW5kaWNhdGUgdGhhdCBzdWNoXG4gKiByZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuXG4gKlxuICogVE9ETzogd2UgbWlnaHQgbmVlZCBhIGZlYXR1cmUgdG8gc3VwcG9ydCB2YWxpZGF0aW9uIG9mIFwiVVJMXCIgYmFzZWQgZGVmaW5pdGlvbnMgaW4gdGhlIGZ1dHVyZSwgc29cbiAqIHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBvcHBvcnR1bml0eSB0byBjYWxsIHJlc29sdmUoKSB3aXRoIGVtcHR5IGN0eC5cbiAqXG4gKiBUT0RPOiBhZGQgcGVyLWZpbGUvcGVyLXVybCBjYWNoZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIEEgcGF0aCBpbiB0aGUgeWFtbCBkb2N1bWVudCB3aGljaCBpcyB0byBiZSByZXNvbHZlZFxuICogQHBhcmFtIHsqfSBjdHggSlNPTiBPYmplY3Qgd2l0aCB0aGUgZG9jdW1lbnQgZmllbGQgd2hpY2ggcmVwcmVzZW50cyB0aGUgWUFNTCBzdHJ1Y3R1cmVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShsaW5rLCBjdHgsIHZpc2l0ZWQgPSBbXSkge1xuICBjb25zdCBsaW5rU3BsaXR0ZWQgPSBsaW5rLnNwbGl0KCcjLycpO1xuICBpZiAobGlua1NwbGl0dGVkWzBdID09PSAnJykgbGlua1NwbGl0dGVkWzBdID0gY3R4LmZpbGVQYXRoO1xuICBjb25zdCBbZmlsZVBhdGgsIGRvY1BhdGhdID0gbGlua1NwbGl0dGVkO1xuXG4gIGNvbnN0IHJlc29sdmVkRmlsZVBhdGggPSAoaXNGdWxseVF1YWxpZmllZFVybChjdHguZmlsZVBhdGgpIHx8IGlzRnVsbHlRdWFsaWZpZWRVcmwoZmlsZVBhdGgpKVxuICAgID8gcmVzb2x2ZVVybChjdHguZmlsZVBhdGgsIGZpbGVQYXRoKVxuICAgIDogcmVzb2x2ZUZpbGUoZGlybmFtZShjdHguZmlsZVBhdGgpLCBmaWxlUGF0aCk7XG5cbiAgbGV0IGRvY3VtZW50O1xuICBsZXQgc291cmNlO1xuXG4gIGNvbnN0IGlzQ3VycmVudERvY3VtZW50ID0gcmVzb2x2ZWRGaWxlUGF0aCA9PT0gY3R4LmZpbGVQYXRoO1xuXG4gIHB1c2hQYXRoKGN0eCwgcmVzb2x2ZWRGaWxlUGF0aCwgW10pO1xuXG4gIGNvbnN0IHJlc29sdmVkTGluayA9IGAke3Jlc29sdmVkRmlsZVBhdGh9Iy8ke2RvY1BhdGh9YDtcblxuICBpZiAoIWlzQ3VycmVudERvY3VtZW50KSB7XG4gICAgaWYgKGN0eC5yZXNvbHZlQ2FjaGVbcmVzb2x2ZWRGaWxlUGF0aF0pIHtcbiAgICAgICh7IHNvdXJjZSwgZG9jdW1lbnQgfSA9IGN0eC5yZXNvbHZlQ2FjaGVbcmVzb2x2ZWRGaWxlUGF0aF0pO1xuICAgIH0gZWxzZSBpZiAoZnMuZXhpc3RzU3luYyhyZXNvbHZlZEZpbGVQYXRoKSkge1xuICAgICAgY3R4LmZpbGVEZXBlbmRlbmNpZXMuYWRkKHJlc29sdmVkRmlsZVBhdGgpO1xuICAgICAgLy8gRklYTUU6IGlmIHJlZmVybmNlZCBlLmcuIG1kIGZpbGUsIG5vIG5lZWQgdG8gcGFyc2VcbiAgICAgIHNvdXJjZSA9IGZzLnJlYWRGaWxlU3luYyhyZXNvbHZlZEZpbGVQYXRoLCAndXRmLTgnKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50ID0geWFtbC5zYWZlTG9hZChzb3VyY2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjdHgucmVzdWx0LnB1c2goY3JlYXRlWUFNTFBhcnNlRXJyb3IoZSwgY3R4LCByZXNvbHZlZEZpbGVQYXRoKSk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHVuZGVmaW5lZCB9O1xuICAgICAgfVxuICAgICAgLy8gRklYTUU6IGxvc3QgeWFtbCBwYXJzaW5nIGFuZCBmaWxlIHJlYWQgZXJyb3JzIGhlcmVcbiAgICB9IGVsc2UgaWYgKGlzRnVsbHlRdWFsaWZpZWRVcmwocmVzb2x2ZWRGaWxlUGF0aCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICB4aHIub3BlbignR0VUJywgZmlsZVBhdGgsIGZhbHNlKTtcbiAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgICAgIH1cblxuICAgICAgICBzb3VyY2UgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBkb2N1bWVudCA9IHlhbWwuc2FmZUxvYWQoc291cmNlKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRklYTUU6IGxvc3QgeWFtbCBwYXJzaW5nIGVycm9ycyBhbmQgbmV0d29yayBlcnJvcnMgaGVyZVxuICAgICAgICByZXR1cm4geyBub2RlOiB1bmRlZmluZWQgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgbm9kZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50ID0gY3R4LmRvY3VtZW50O1xuICAgIHNvdXJjZSA9IGN0eC5zb3VyY2U7XG4gIH1cblxuICBpZiAoc291cmNlKSBjdHgucmVzb2x2ZUNhY2hlW3Jlc29sdmVkRmlsZVBhdGhdID0geyBzb3VyY2UsIGRvY3VtZW50IH07XG5cbiAgY3R4LnNvdXJjZSA9IHNvdXJjZTtcbiAgY3R4LmRvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgY29uc3QgZG9jUGF0aFN0ZXBzID0gZG9jUGF0aCA/IGRvY1BhdGguc3BsaXQoJy8nKS5maWx0ZXIoKGVsKSA9PiBlbCAhPT0gJycpLnJldmVyc2UoKSA6IFtdO1xuXG4gIGxldCB0YXJnZXQgPSBkb2N1bWVudDtcbiAgbGV0IGNpcmN1bGFyO1xuICBsZXQgdHJhbnNpdGl2ZVJlc29sdmVzT25TdGFjayA9IDA7XG4gIGxldCB0cmFuc2l0aXZlRXJyb3I7XG5cbiAgaWYgKHZpc2l0ZWQuaW5kZXhPZihyZXNvbHZlZExpbmspID4gLTEpIHtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuICB9XG5cbiAgdmlzaXRlZC5wdXNoKHJlc29sdmVkTGluayk7XG5cbiAgd2hpbGUgKHRhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuJHJlZikge1xuICAgICAgLy8gaGFuZGxlIHRyYW5zaXRpdmUgJHJlZidzXG4gICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmUodGFyZ2V0LiRyZWYsIGN0eCwgdmlzaXRlZCk7XG4gICAgICB0cmFuc2l0aXZlRXJyb3IgPSByZXNvbHZlZC50cmFuc2l0aXZlRXJyb3I7XG4gICAgICBpZiAocmVzb2x2ZWQubm9kZSA9PT0gdW5kZWZpbmVkICYmICF0cmFuc2l0aXZlRXJyb3IpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBzaG93IG9ubHkgdGhlIGVycm9yIGZvciB0aGUgZmlyc3QgJHJlZiB0aGF0IGNhbid0IGJlIHJlc29sdmVkLlxuICAgICAgICAvLyBTbyB3ZSBjcmVhdGUgaXQgb24gdGhlIGN1cnJlbnQgc3RhY2sgYW5kIHByb3BhZ2F0ZSBpdCBvdXQgYXMgYSB0cmFuc2l0aXZlRXJyb3JcbiAgICAgICAgcG9wUGF0aChjdHgpO1xuICAgICAgICBjdHgucGF0aC5wdXNoKCckcmVmJyk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSByZXNvbHZlZC5jaXJjdWxhciA/ICdDaXJjdWxhciByZWZlcmVuY2UuJyA6ICdSZWZlcmVuY2UgZG9lcyBub3QgZXhpc3QuJztcbiAgICAgICAgdHJhbnNpdGl2ZUVycm9yID0gY3JlYXRlRXJyb3IobWVzc2FnZSwgdGFyZ2V0LCBjdHgsIHsgZnJvbVJ1bGU6ICdyZXNvbHZlLXJlZicgfSk7XG4gICAgICAgIGN0eC5wYXRoLnBvcCgpO1xuICAgICAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGFyZ2V0ID0gcmVzb2x2ZWQubm9kZTtcbiAgICAgIHRyYW5zaXRpdmVSZXNvbHZlc09uU3RhY2srKztcbiAgICB9XG5cbiAgICBjb25zdCBzdGVwID0gZG9jUGF0aFN0ZXBzLnBvcCgpO1xuICAgIGlmICghc3RlcCkgYnJlYWs7XG5cbiAgICB0YXJnZXQgPSB0YXJnZXQgJiYgdGFyZ2V0W3N0ZXBdICE9PSB1bmRlZmluZWQgPyB0YXJnZXRbc3RlcF0gOiB1bmRlZmluZWQ7XG4gICAgY3R4LnBhdGgucHVzaChzdGVwKTtcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNpdGl2ZVJlc29sdmVzT25TdGFjazsgKytpKSB7XG4gICAgLy8ga2VlcCBjdXJyZW50IGZpbGUgY29udGV4dCBhbmQgcmVtb3ZlIGluZGlyZWN0aW9uIHJlY29yZHNcbiAgICBjdHgucGF0aFN0YWNrLnBvcCgpO1xuICB9XG5cbiAgaWYgKHRyYW5zaXRpdmVFcnJvcikge1xuICAgIC8vIHJlY2FsYyByZWZlcmVuY2VkRnJvbSBhZnRlciBleGl0aW5nIHRyYW5zaXRpdmUgcmVmIHN0YWNrIHRvIHNob3cgb3JpZ2luYWwgJHJlZiBpbiB0aGUgZXJyb3JcbiAgICB0cmFuc2l0aXZlRXJyb3IucmVmZXJlbmNlZEZyb20gPSBnZXRSZWZlcmVuY2VkRnJvbShjdHgpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBub2RlOiB0YXJnZXQsXG4gICAgdHJhbnNpdGl2ZUVycm9yLFxuICAgIGNpcmN1bGFyLFxuICB9O1xufVxuXG5cbi8qXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVzb2x2ZSAkcmVmIGZpZWxkcyBpbnNpZGUgdGhlIG5vZGUuIEN1cnJlbnRseSBzdXBwb3J0cyBsaW5rczpcbiAqIC0gaW5zaWRlIHRoZSBmaWxlXG4gKiAtIHRvIHRoZSBhbm90aGVyIGZpbGUgaW4gbG9jYWwgZmlsZSBzeXN0ZW1cbiAqIC0gaHR0cChzKSBsaW5rcyB0byBvdGhlciBmaWxlc1xuICpcbiAqICRyZWYgZmllbGQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIE9wZW5BUEkgbGlua1xuICogKGUuZy4gYW5vdGhlci9kaXIvZmlsZS55YW1sIy9jb21wb25lbnRzL3NjaGVtYXMvRXhhbXBsZSlcbiAqXG4gKiBAcGFyYW0geyp9IG5vZGVcbiAqIEBwYXJhbSB7Kn0gY3R4XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIGN0eCkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSByZXR1cm4geyBub2RlIH07XG5cbiAgaWYgKG5vZGUuJHJlZikge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZShub2RlLiRyZWYsIGN0eCk7XG4gICAgaWYgKHJlc29sdmVkLm5vZGUgPT09IHVuZGVmaW5lZCkgeyAvLyBjYW4ndCByZXNvbHZlXG4gICAgICBwb3BQYXRoKGN0eCk7XG5cbiAgICAgIGN0eC5wYXRoLnB1c2goJyRyZWYnKTtcbiAgICAgIGNvbnN0IGVycm9yID0gcmVzb2x2ZWQudHJhbnNpdGl2ZUVycm9yXG4gICAgICAgID8gcmVzb2x2ZWQudHJhbnNpdGl2ZUVycm9yXG4gICAgICAgIDogY3JlYXRlRXJyb3IoJ1JlZmVyZW5jZSBkb2VzIG5vdCBleGlzdC4nLCBub2RlLCBjdHgsIHsgZnJvbVJ1bGU6ICdyZXNvbHZlLXJlZicgfSk7XG4gICAgICBjdHgucGF0aC5wb3AoKTtcblxuICAgICAgY3R4LnJlc3VsdC5wdXNoKGVycm9yKTtcblxuICAgICAgcmV0dXJuIHsgbm9kZSB9O1xuICAgIH1cblxuICAgIHJldHVybiB7IG5vZGU6IHJlc29sdmVkLm5vZGUsIG9uU3RhY2s6IHRydWUgfTtcbiAgfVxuXG4gIHJldHVybiB7IG5vZGUgfTtcbn1cblxuLy8gdG8gYmUgdXNlZCBpbiBtdXRhdG9yc1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVOb2RlTm9TaWRlRWZmZWN0cyhub2RlLCBjdHgpIHtcbiAgY29uc3QgY3R4Q29weSA9IHsgLi4uY3R4LCBwYXRoU3RhY2s6IGN0eC5wYXRoU3RhY2suc2xpY2UoKSB9O1xuICByZXR1cm4gcmVzb2x2ZU5vZGUobm9kZSwgY3R4Q29weSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVOb2RlO1xuIl19